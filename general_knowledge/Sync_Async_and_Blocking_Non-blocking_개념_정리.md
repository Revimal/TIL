# Sync/Async & Blocking/Non-blocking 개념 정리

_2022/01/06_

### 이론적 정의

* A가 B에게 어떤 작업을 요청한다고 정의하자

* 이때 A와 B는 컨텍스트[^1][^2]일수도 있고 아닐 수도 있다고 가정하자

##### Sync / Async [^3][^4]

* Sync (Synchronous, 동기)
  * **작업에 대한 책임이 A에게 있다**
  * **A와 B는 다른 컨텍스트일 필요는 없다**
  * A는 B가 작업을 끝낼 때까지 **계속 관심을 가져야** 한다
  * A는 B에게 맡겨놓은 **작업이 끝나는 시점**에 다른 것을 시작한다.
* Async (Asynchronous, 비동기)
  * **작업에 대한 책임이 B에게 있다**
  * **A와 B는 다른 컨텍스트여야 할 것이다**
  * A는 B에게 작업을 요청하고 나면 **아무 상관하지 않아도** 된다
  * A는 B에게 맡겨놓은 **작업이 끝나는 시점과 관계 없이** 다른 것을 시작한다.

##### Blocking / Non-blocking [^5][^6]

* Blocking (블로킹)
  * **작업이 끝날 때까지 A의 동작은 멈추어야 한다**
  * **A와 B는 다른 컨텍스트일 필요는 없다**
  * A는 B가 작업을 끝낼 때까지 계속 **기다려야** 한다
  * A는 B에게 맡겨놓은 작업이 끝날 때까지 **아무것도 할 수 없다**.
* Non-blocking (논블로킹)
  * **작업이 끝났던 아니던 A의 동작은 계속될 수 있다**
  * **A와 B는 다른 컨텍스트여야 할 것이다**
  * A는 B가 작업을 끝낼 때까지 **다른 일을 해도** 된다
  * A는 B에게 맡겨놓은 작업이 끝날 때까지 **아무거나 할 수 있다**.

### 조금 덜 정확하지만 조금 더 이해하기 쉬운 예시

##### Sync + Blocking

* 내가 **책임지고** 작업이 진행되는 동안 지켜봐야 하고, 작업이 끝날 때까지 **아무것도 못 한다**.

* 그나마, 현실에 가까운 동작 예시를 들자면,
  1. 유튜브를 보고 있다
  2. 그런데 배가 고파졌다
  3. 배달의 민족 앱으로 치킨을 시켰다
  4. 치킨이 도착할 때까지 계속 배달 현황을 지켜보고 있는다

##### Sync + Non-blocking

* 내가 **책임지고** 작업 상태를 계속 확인해야 하지만, 작업이 끝날 때까지 **다른 걸 해도 된다**.
* 그나마, 현실에 가까운 동작 예시를 들자면,
  1. 유튜브를 보고 있다
  2. 그런데 배가 고파졌다
  3. 배달의 민족 앱으로 치킨을 시켰다
  4. 배달이 접수된 것을 확인하고 앱을 끈다
  5. 다시 유튜브를 보면서 생각날 때마다 배달 현황을 한번씩 확인한다

##### Async + Blocking

* 작업을 요청하면 그걸로 내 **책임은 끝**이지만, 작업이 끝날 때까지 **아무것도 못 한다**.
* 그나마, 현실에 가까운 동작 예시를 들자면,
  1. 유튜브를 보고 있다
  2. 그런데 배가 고파졌다
  3. 배달의 민족 앱으로 치킨을 시켰다
  4. 치킨은 어차피 배달부가 가져다 줄테니 딱히 신경쓸 건 없지만, 배가 고파서 아무것도 못할 것 같다
  5. 그래서 치킨이 올 때까지 멍하니 누워만 있는다

##### Async + Non-blocking

* 작업을 요청하면 그걸로 내 **책임은 끝**이고, 작업이 끝날 때까지 **다른걸 해도 된다**.
* 그나마, 현실에 가까운 동작 예시를 들자면,
  1. 유튜브를 보고 있다
  2. 그런데 배가 고파졌다
  3. 배달의 민족 앱으로 치킨을 시켰다
  4. 배달이 접수된 것을 확인하고 앱을 끈다
  5. 치킨은 어차피 배달부가 가져다 줄테니, 초인종이 울릴 때까지 다시 유튜브를 본다

### 실무를 거치면서 느낀 점

* `Sync/Async`와 `Blocking/Non-blocking`은 **분류 하려는 목적**이 다르다.

* 흔히 봐왔던, 네모 4개짜리 그림[^7]으로 모든 상황이 칼같이 나뉘어서 설명되는지는 않는다.

* 대부분의 사람들이 알고 있는 것과는 달리, 모든 상황에서 `Async + Non-blocking`이 항상 효율적이지는 않다.

  * Busy-waiting[^8]을 할 수 있는 상황이라면, 컨텍스트 스위칭이 필수적인 `Async + Non-blocking`은 지연 시간 관점에서 비효율적이다[^9].

* 대부분의 사람들이 알고 있는 것과는 달리, `Sync + Blocking`이 못 써먹을 정도로 비효율적이지도 않다.

  * 일반적인 운영체제에서 `Blocking` 동작 동안에는 CPU 자원을 반환케 된다[^10][^11].

  * 따라서, 같은 컨텍스트를 여러 개 복제해서 `Sync + Blocking`으로 구성하면 성능도 어느정도 챙길 수 있다[^12].

* 개인적으로는 `Async + Blocking`은 `Sync + Blocking`하고 다를게 없다고 본다.

  * `Async`로 구현하려고 책임 위임 코드를 짜다보니, 코드 복잡도가 증가했다.
  * 다음 로직을 태우려면 작업 완료가 된 데이터가 필요해서, 동작은 `Blocking`이 되었다.
  * `Sync + Blocking`이 유지보수 하기에 더 편한데 동작은 그대로니까, `Async + Blocking`은 의미가 없어진다.
  * 어차피 정상적인 개발자라면 `Sync + Blocking`으로 리팩토링 할테니까, 결과론적으로 `Async + Blocking`은 `Sync + Blocking`이 된다.
  * 아니면 데이터의 종속성을 제거해서, 아예 `Async + Non-blocking`으로 넘어가던가.

---

[^1]: 이하, 본 문서에서 칭하는 '컨텍스트'라는 용어는 "또 다른 '컨텍스트'에 독립적으로 작업을 수행할 수 있는 개체"라고 약속하자
[^2]: 이게 대체 무슨 소리인가 싶겠지만, '스레드', '프로세스', '컨테이너', '가상머신', '서버' 등의 단어를 '컨텍스트' 대신 대입하면 어떤 의미인지 이해될 것이다
[^3]: "A에게 작업의 **책임**이 있냐"에 따라 구분된다고 보면 된다
[^4]:"A가 **작업이 끝나는 시점**부터 다른 걸 할 수 있는지"에 따라 구분된다고도 말할 수 있다
[^5]: "A의 **동작**이 멈춰야 하냐"에 따라 구분된다고 보면 된다
[^6]: "A가 작업이 진행되는 중에도 **아무거나 할 수 있는지**"에 따라 구분된다고도 말할 수 있다
[^7]: ![Sync/Async & Blocking/Non-blocking](../img/general_knowledge/Sync_Async_and_Blocking_Non-blocking_matrix.gif)
[^8]: "이벤트 루프를 중단 조건 없이 돌면서 매번 이벤트 큐를 확인하고, 새로운 이벤트가 발견되면 그때그때 꺼내서 처리하는 것"을 예시로 들 수 있을 것 같다
[^9]: Busy-waiting을 수행하는 CPU 코어의 사용률이 100% 점유하는 단점이 있다는 것을 고려하면, 사용 목적이 다르다고 볼 수 있겠다
[^10]: 여기서 헷갈리지 말아야 할 건, 컨텍스트 입장에서는 여전히 "작업이 끝나는 시점까지 동작이 멈춰있는 중"이라는 것이다
[^11]:  그러나 전체 시스템 관점에서 보면, 스케쥴러가 "너 어차피 기다리는 중이면 CPU 자원 필요없지? 알아서 때 되면 깨워줄게"하고 컨텍스트를 재우는 것
[^12]: `Blocking` 작업 동안 컨텍스트가 CPU 자원을 반환하면, 다른 컨텍스트가 그걸 들고 자신의 `Blocking` 작업이 올 때까지 동작하면서 부하가 분산 된다

---

##### Image Reference

1. [img/general_knowledge/Sync_Async_and_Blocking_Non-blocking_matrix.gif](https://developer.ibm.com/articles/l-async/)
